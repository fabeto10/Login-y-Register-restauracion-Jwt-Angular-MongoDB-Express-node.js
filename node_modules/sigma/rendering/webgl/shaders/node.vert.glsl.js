(()=>{"use strict";var o={d:(t,n)=>{for(var i in n)o.o(n,i)&&!o.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:n[i]})},o:(o,t)=>Object.prototype.hasOwnProperty.call(o,t),r:o=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})}},t={};o.r(t),o.d(t,{default:()=>n});const n="attribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\nattribute vec4 a_color;\n\nuniform mat3 u_matrix;\nuniform float u_sqrtZoomRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\nconst float marginRatio = 1.05;\n\nvoid main() {\n  float size = a_size * u_correctionRatio * u_sqrtZoomRatio * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector * marginRatio;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_border = u_correctionRatio * u_sqrtZoomRatio * u_sqrtZoomRatio;\n  v_diffVector = diffVector;\n  v_radius = size / 2.0 / marginRatio;\n\n  v_color = a_color;\n  v_color.a *= bias;\n}\n";module.exports=t})();